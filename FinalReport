Luke Allocco, Elizabeth Bui, Christian Burns, Jonathan Shih, Daniel Yost
Mrs. Gerstein
Intro to Programming
28 January 2016
	The code of our game is in depth and a great example of our understanding of Processing and its many uses. While selecting what kind of game to code, we looked at many different types of games. We took a look at Frogger, Brick Breaker, and several others. After a brief period of brainstorming, we came up with the idea of combining a number of different mini games into one larger game. Our group took a look at the game “Keep Talking and Nobody Explodes” for some inspiration. The game includes a bomb with multiple puzzles inside and a constantly ticking timer. One of the two people can see the bomb, while the other looks at a bomb defusal manual. In order to beat the game, all puzzles must be complete before time runs out. We are able to include the format, the concept, and the basic controls from “Keep Talking and Nobody Explodes”. The challenge was to switch it from a co-op game to a single player game. We took a conscious note to make all of our mini games possible to complete by one person. Along with editing the challenges inside the bomb, we also removed the defusal manual. 
    Something that we’re all proud of is that we were able to learn and take advantage of modules in Processing. By learning modules, we learned new code, and we learned a new way of combining various objects with similarities into one. If modules weren’t used, the code for each game would just be stacked one on top of another, making it difficult to locate the desired block of code. Since we decided to use them, the code was split up and organized according to each minigame. If there is a problem with Brick Breaker, you would simply go to the Brick Breaker module and edit the code accordingly. Outside of the actual code, we are all proud of the final project and being able to see what your part of the game working together with the others to make an entire project. To start the code, we created the timer of the bomb and a simple layout for all the mini games. Most of us were assigned a mini game, and the ones who weren’t assigned one were in charge of touching up and improving the games. When a mini game was complete, it would be transferred into the main code for the final game. After all of the games were done and in the main code, Dan had the idea of creating different difficulties by playing with the values of variables within the code. Difficulties were created and a selection screen was placed at the beginning of the game.
    Throughout the creation process, we often felt stressed and confused as to what to do next and how to do it. The code always looked organized, but we definitely were not. As the code progressed, we feel we did too. We got into a rhythm of work each time we met. Each person had one or more jobs to complete before the day was over, and for the most part, we stuck to it. We worked with efficiency and with the sole purpose of having a final product in the end. We worked on it diligently and reworked it a number of times to get it to where we first imagined it. With our final product finally done, it is safe to say we had a fun time doing it, and we hope you have just as much fun playing it! 
